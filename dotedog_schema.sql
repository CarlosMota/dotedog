CREATE database dotedogdb;

\connect dotedogdb

CREATE TABLE UserProfile (
    UserID BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    Name Text NOT NULL,
    EmailAddress Text NOT NULL UNIQUE,
    DateOfBirth DATE NOT NULL,
	PhoneNumber VARCHAR(15) NOT NULL UNIQUE,
    Address Text NOT NULL,
    City VARCHAR(20)NOT NULL,
    State VARCHAR(20)NOT NULL,
    Zipcode VARCHAR(20) NOT NULL,
    IsActive BOOLEAN NOT NULL DEFAULT true
);


CREATE TABLE UserAuth (
    UserID BIGINT PRIMARY KEY,
    Username Text NOT NULL UNIQUE,
    PasswordHash CHAR(60) NOT NULL, -- Considerando o uso de bcrypt, que gera hashes de tamanho fixo
    Salt Text NOT NULL, -- O tamanho do salt pode variar de acordo com a implementação
    AuthToken Text, -- Token opcional para autenticação/recuperação de senha
    CONSTRAINT fk_user_profile
        FOREIGN KEY(UserID) 
        REFERENCES UserProfile(UserID)
        ON DELETE CASCADE
);

CREATE TABLE species(
  Id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  Name TEXT
);

CREATE OR REPLACE FUNCTION fc_UserProfile_Get(P_UserName TEXT DEFAULT NULL)
RETURNS setof userprofile  AS $$
BEGIN
    IF P_UserName IS NULL THEN
        RETURN QUERY select u.* 
                       from userauth a
                      inner join userprofile u
	                     on a.userid = u.userid
                      where a.username = P_UserName;
    ELSE
        RETURN QUERY SELECT * from userprofile;
    END IF;
END;
$$ LANGUAGE plpgsql;

CREATE EXTENSION IF NOT EXISTS pgcrypto;

CREATE OR REPLACE PROCEDURE public.sp_userprofile_createuser(p_name text, p_emailaddress text, p_dateofbirth date, p_phonenumber character varying, p_address text, p_city character varying, p_state character varying, p_zipcode character varying, p_username text, p_password text)
 LANGUAGE plpgsql
AS $procedure$
DECLARE
    v_UserID BIGINT;
    v_Salt TEXT;
    v_PasswordHash TEXT;
BEGIN
    -- Gerar salt
    v_Salt := gen_salt('bf'); -- 'bf' é para bcrypt. Ajuste de acordo com as necessidades de segurança.

    -- Hash da senha com salt
    v_PasswordHash := crypt(p_Password, v_Salt);
    
    -- Inserir em UserProfile
    INSERT INTO UserProfile(Name, EmailAddress, DateOfBirth, PhoneNumber, Address, City, State, Zipcode)
    VALUES (p_Name, p_EmailAddress, p_DateOfBirth, p_PhoneNumber, p_Address, p_City, p_State, p_Zipcode)
    RETURNING UserID INTO v_UserID;
    
    -- Inserir em UserAuth
    INSERT INTO UserAuth(UserID, Username, PasswordHash, Salt)
    VALUES (v_UserID, p_Username, v_PasswordHash, v_Salt);
    
    COMMIT;
END;
$procedure$
;

